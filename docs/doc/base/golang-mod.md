# Golang 依赖管理进化史

诚然，说进化史有些大。 不免有些夸大其词的感觉，但从golang 1.x 到最新的golang 1.18，golang的依赖管理一路跌跌撞撞，总算是大功告成，也对得起进化史这三个字了。

为了可以直观看到golang 依赖管理的进化历程，我根据自我理解做了下面这张图:
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h16675dlvsj21p40nyjy5.jpg)

从时间节点中划分，golang的依赖管理大致分为四个阶段:

+ 草莽英雄。 在1.11之前，golang延续的是google的依赖管理风格(没有所谓的版本概念，所有代码都使用同一个版本的依赖)。这个阶段的特点是，所有的golang project都复用相同的依赖。无论是Project A还是Project B，依赖的代码都是同一份(根本原因在于所有的依赖保存在gopath中，所以依赖完全相同)。 如果想分离依赖，那好办。自己创建vendor目录，自己维护vendor。

+ 三国纷争。后来golang官方意识到，不是所有的公司都叫google，不是所有的开发都是`研发`(中间还夹杂着golang姓`G`还是姓`社`的斗争)。为了照顾那些技术底子不强的公司，golang官方实验性质的推出了`go.mod`文件，这个文件保存着当前工程所有的依赖文件和版本。因为是实验性质，所以推出了`GO111MODULE`这个环境变量来启动或者关闭。与此同时围绕着`go.mod`文件，也推出了一些工具。但最常用的还是`godep`。 后来golang掌门人连发几篇博文阐述`vgo`方案，虽然社区有很多反对的声音，但最终胳膊肘子拧不过脖领盖儿，golang在1.13的时候正式将`vgo`扶正，变成了`go module`方案

+ 一统天下。 从1.13到1.17，伴随着社区对`go module`精神的深入学习，大家一致认为虽然`rsc`行事粗鲁，但小伙思想还是挺具有前瞻性的。 `go module`尽管有这样那样不好的地方，但和以前的依赖管理方案比起来，强太多了。社区届纷纷表示`真香大法`就是好。

+ 继往开来。 在1.18中，伴随着`go workspace`的落地，golang的依赖管理方案算是完成了万里长征最后一步，不但修复了`go module`遗留的那些个毛病，顺手还做了精神升华。

## go module的好

## go module的坏

## go workspace解决了哪些问题