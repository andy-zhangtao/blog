# ServerLess 入门理论

曾几何时，很多公司尤其是互联网公司创业的时候，都会采购硬件机器搭建自己的IDC。 后来AWS开始售卖多余的机器资源，公有云的时代就这么悄然而至。

从AWS开始售卖机器资源开始，国内外的头部互联网公司都开始进入Paas市场。 目前来说，如果想成立一家互联网创业公司，已经不会再考虑采买硬件机器了，99%都会采购公有云上面的机器资源。 这样可以节省很多的机器成本，但在节省成本的路上还有很多的可以优化的空间。 尤其是在这两年疫情反复的大背景下，能少花就不多花，能不花就不少花变成了很多公司不约而同的选项。

那如何再节省一些费用呢？ 可以考虑考虑Serverless了。

## 何为Serverless？
Serverless，又叫无服务器。Serverless 强调的是一种架构思想和服务模型，让开发者无需关心基础设施（服务器等），而是专注到应用程序业务逻辑上。

**无服务器!=没有服务器**

对于开发者来说，是不需要关心服务器的运维了。而这部分服务器的运维则转移到了公有云厂商的头上。 说白了: **用户花钱买运维** 。

在虚拟机时代，用户花钱购买机器资源。 公有云提供相对应规格的资源，你想做啥就做啥，自负盈亏。公有云厂商只会保证母机稳定不故障，至于虚拟机里面的事情，就需要自己亲力亲为了。 如果切换到了Serverless，用户此时购买的就不是机器资源了，而是CPU和内存。 用户只需要保证函数逻辑正常不出错就可以了，至于函数运行在哪个节点上，用户不需要关心。 因为你购买的是CPU和内存，公有云厂商只要给你要求的CPU和内存就够了。


![](https://tva1.sinaimg.cn/large/008i3skNly1gy773s9zvwj30sg0agjsf.jpg)

这就正好应了那句老话，鸡蛋好吃，你需要关心哪只母鸡下的么？

## Serverless的优劣

听起来Serverless好像是一个银弹，但根据 **“有得必有失”** 的原则，Serverless必然有其优劣。

1. 可以重复利用硬件资源

因为Serverless是函数粒度，所以在资源编排上面可以实现见缝插针。 比如有一个函数，需要0.02C/32MB的资源。  现在只要有一个节点有这么一点资源，Serverless调度平台就可以将这个函数调度过去，并且运行起来。

如果不是Serverless，除非是极端的微服务(一个实例一个服务，并且一个服务就一个函数)，否则大部分微服务都是一个实例对外提供N个服务，每个服务又使用了很多的函数。 想要运行这么一个微服务，就不是0.02C/32MB这么低资源可以承受的了。

所以使用Serverless，可以尽可能的压榨硬件资源。

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78z97wbnj31my0jswg5.jpg)

2. 更快的服务迭代速度

Serverless基本调度单位是函数，开发一个函数所需要的时间大大低于开发一个服务所需要的时间。 同时一个函数里面的业务逻辑复杂度远远低于一个函数的业务复杂度(一个函数上千行，这么情况不在考虑范畴之内)。

所以说，使用Serverless以后，修改业务逻辑会变得非常快。 从这个角度而言， Serverless 就是极致微服务的表现。

3. 快速伸缩容

这个优点离不开Serverless的函数本质， 假设我们写的是典型微服务(一个实例对外提供多个服务)。 那么这个微服务多多少少都需要链接各种中间件。 启动这样一个微服务，大多数都需要分钟级(中位数，不考虑特例)。

如果变成Serverless以后， 首先不再需要频繁创建中间件了(Serverless分为Faas和Baas。 Faas用于无状态服务，不依赖中间件。 Baas用于状态保持，需要依赖中间件)。

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78yewlknj30ws0u03z5.jpg)

对于Faas来说，每次的请求就是单纯的CPU计算(例如文中最后的实例)，启动会非常快(服务启动慢大多数都是阻塞在IO)。

对于Baas来说，虽然也依赖中间件，但会通过预热提前提供好中间件链接池。同时对于Baas的扩容来说，优先扩容函数。 只有当函数扩容到达上限天花板后，才会扩容实例。 所以Baas最差的启动时间才会和微服务打个平手。

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78yrizhwj319f0u0myj.jpg)

4. 省人工

Serverless只需要开发业务逻辑，连运维都不需要考虑。 实在是公司裁人最好的利器，而且杀人诛心。 裁员于无形当中。

上面三个是主要优点，第四个是白送。  我们在来看缺点：

1. 响应延时高

并不是每次的响应延时都会高，只是会把TP95拉高。 因为Serverless不是long-running类型的服务，当没有请求时，对应的函数实例就会缩减成0.

假设在函数实例为0的时候，来了一(大)波请求，此时因为没有可用实例，所以需要实时创建。 那么这些请求其实就会被暂时阻塞在某个环节中，等实例都创建成功以后，才能处理这些请求。

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78xreg5nj31h20g23z7.jpg)

因此只有当后端可用函数实例为0时，才会出现延时高的情况。 如果现在有可用函数实例，延时不会高很多。

2. 状态管理

要想实现自由的缩放，无状态是必须的，而对于有状态的服务，使用 serverless 这就丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。

3. 本地测试

Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。


## Serverless的触发模型

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78848qazj31m80i8my0.jpg)

这是Faas最简洁的触发模型。

当请求到达trigger模块以后， trigger简单进行流量处理，就把请求发往流控模块之中。 流控此时就需要判断后端有没有足够的Faas实例。如果有就转发过去，如果没有就短暂的进行流量挟持(将请求暂时寄存在内存之中)，等后端的Faas创建好以后，再把流量转发过去。

从流量挟持开始，到后端Faas创建好为止，这段时间就称之为 Faas的冷启动时间。

在trigger组件中，可以对接多个trigger源。
![](https://tva1.sinaimg.cn/large/008i3skNly1gy78bf00p4j30tm0r6tab.jpg)

例如图中所示的网关、IOT设备和APP等等，都算trigger源。

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78zm6vjij30u010zmy7.jpg)

一般来说，Serverless处理的请求分为两类：
1. API调用类
2. 离线计算类


API调用类就是需要等待Faas明确返回结果，比如图片裁剪，格式转换，获取结果等等。 这些请求从trigger源会直接到达Faas层。

而离线计算类则不需要马上等待结果，例如下发验证码请求，离线记账请求等等。 这些请求从trigger源会进入一个mq进行排队，Faas慢慢消化处理就可以了。 典型的就比如下发验证码请求。用户请求一个验证码，请求到达trigger后，trigger将这个请求放入MQ中。 此时就可以让用户准备接受验证码了。  Faas从MQ中读取事件，调用相关接口下发一个验证码给指定用户。


Baas的触发模式和Faas类似，只不过多了一些中间件链接初始化的环节。本质上和Faas的模式非常类似。

## 一个Faas的实现

最后，我们来看一个实际的Faas案例。  我选择的是获取用户公网IP这样一个场景。 当用户请求指定API时，API会返回当前请求客户端的公网IP。 效果如下：

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78khnor9j31140jidgo.jpg)

还可以指定返回的格式，方便API处理

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78kqtw5wj314y0fywfg.jpg)

###  代码实现

这个服务部署在阿里云的函数计算 FC服务中。阿里云的函数计算 FC支持两种实现模型：
1. 直接编写代码
2. 上传用户指定的镜像。

因为我有一个现成的服务，所以我选择的第二种方式，直接上传构建好的镜像。

先来看代码部分:

`main.go`

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78qgmjtdj30ue09mmxw.jpg)

因为是上传整个镜像，所以需要创建一个web容器。 kg是github.com/KataSpace/Kata-Gin 这个库，可以自动的根据Struct中的定义生成对应的API接口，非常好用。

而返回IP的代码如下:

![](https://tva1.sinaimg.cn/large/008i3skNly1gy78sbwyuaj30u00v9jud.jpg)

MyIP 这个struce只有一个Get函数，所以kg会生成`GET  / `这样的接口。 如果是GetMyIP这样的函数名称，那么就会生成 `GET /MyIP`这样的接口。

打包构建上传到阿里云的镜像仓库，我通过自动化构建得到的镜像名称是:`
registry-vpc.cn-beijing.aliyuncs.com/vikings/common-tools:myip-20211228-1133`

如果是选择第一种编写代码的方式，那么就是忽略main.go里面的内容(Serverless平台会自动补齐main.go里面的内容)，直接写返回IP的逻辑就可以了。


## 总结

Karl Marx说的好，生产力决定生产关系，云计算的概念层出不穷，其本质上还是对生产关系和生产力的配置与优化，生产者抛开场景意味追求高大上的技术将譬如“大炮打蚊子”，小题大做，鼓励大家为了满足大家的好奇心进行折腾，毕竟那么多科学发现和重大发明都是因为折腾出来的，不想要一匹跑的更快的马，而是发明汽车的福特，捣鼓炸药的诺贝尔，种豌豆的孟德尔……同时还是要考虑将技术产业化（或许能改变生产关系），提高生产力。


