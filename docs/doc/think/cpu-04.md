# 关于go-zero性能的一些想法-04CPU性能分析的几个方法论

书再接上文。 上篇大致聊了一下CPU执行队列的一些基本情况，在本文中我们继续聊一聊CPU性能分析的几个常见问题。

在这个系列最开始的时候，我们说所有的性能问题最终都可以归咎到资源竞争。 而在所有的资源竞争中，CPU属于竞争最严重的一部分。当某个进程或者服务遇到性能问题以后，CPU首当其冲排在排查的头一位。

但排查CPU不是一件容易的事情，CPU此时此刻到底在运行哪些事情，到底如何断定CPU是正常还是不正常。如果无法掌握一些方法论，那么排查CPU就变成了一个撞大运的问题。在本文中，我们尝试总结一些定位CPU性能瓶颈的常见方法论。

## 如何判断CPU是否处于资源竞争状态

对于CPU来说，如果想定性判断CPU是否处于资源竞争状态，可以尝试从以下几点进行判断分析：
1. 平均负载(需要结合CPU使用率 和 CPU Load一起来看)
2. 用户态执行时间和内核态执行时间比例
3. 系统调用频次
4. 自愿上下文切换频率
5. 中断(软中断是重点)频率

在这五项中，第二点需要额外解释一下。 正常情况下，用户态执行时间应该大于内核态执行时间。 
+ 用户态执行时间很高，说明当前CPU正在大量计算用户自己的进程代码，这属于正常情况(排除代码bug的影响因素)。
+ 当前内核态执行时间过高，则意味着CPU大量的时间花在执行内核态代码逻辑之中，此时第三点(系统调用频次) 和第五点(中断频率)应该也会同步升高。 那么说明此时此刻CPU在大量进行内核调用，留给用户态时间非常短暂。对客户端来说，就是代码执行时间变长。

为了确认当前CPU是否满足上面这五点，就需要对CPU进行一系列检查，下面是建议的CPU性能检查清单。

## CPU Check List

为了确认CPU是否存在性能问题，需要采集CPU指标数据进行综合研判。 建议采集的数据有：

- 系统CPU使用率是多少，每个CPU的使用率是多少。
- CPU并发程度是多少？
- 每个用户态进程使用了多少的CPU，哪个使用率最高
- 当前内核程序使用了多少的CPU，哪个内核程序使用最高
- CPU花在中断调度上面的时间有多少
- CPU被阻塞了多长时间

为了采集这些数据，我们就需要借助一些工具了。 下面是采集CPU数据常用的工具列表：

## 分析CPU的几个常用工具

1. uptime
> 显示1、5和15分钟内的平均负载。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcujyui8j21ck04adg9.jpg)

uptime计算的是平均负载值，这个值是对CPU使用率和CPU排队队列数(Load)进行加权计算后得出的。 我们一般将这个值与逻辑CPU个数进行比较得出当前是否存在过载的情况。 

+ 如果平均负载 >= CPU个数，那么说明CPU个数不足以服务线程。 
+ 如果平均负载 < CPU个数，那么说明有充足的CPU服务线程。

**磁盘IO也被纳入平均负载的计算公式中，所以有时CPU有空余，磁盘紧张也会引起平均负载过高**

2. vmstat
> 显示CPU详细负载数据

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcvx81saj211s066my8.jpg)

vmstat可以显示CPU更为详细的负载数据。 

|指标|名称|备注|
|---|---|---|
|us｜用户态时间||
|sy|内核态时间||
|id|空闲时间||
|wa|IO等待时间|线程等待磁盘IO所引起的CPU空闲|
|st|被其它租户偷取的时间|CPU执行虚拟化时在其它租户的时间|
|r|运行队列长度||

VMstat显示的所有CPU信息相加以后的数据，如果想看某个CPU的信息，使用uptime或者vmstat都无法实现。此时此刻需要下面的工具。

3. mpstat
> 显示每颗CPU的统计数据

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcwlo97aj21hc0emaee.jpg)

mpstat显示的数据和vmstat显示的数据大致类似，只不过会显示每颗CPU的详细数据。 同时增加了中断数据，例如:

+ irq 硬件中断
+ soft 软中断
+ nice 以nice优先级运行的用户态时间

通过mpstat可以找到`热CPU`，即那些%user+%sys == 100%的CPU。 如果在多核CPU架构中，出现了`热CPU`和`冷CPU`那么就说明可能是用户进程高计算量引起或者由中断所引起。

4. sar
> 观察当前CPU活动，并且支持数据归档和报告历史统计信息。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcxelxsgj20ze0u0dnq.jpg)
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzczet3ytj218u0scdn7.jpg)

5. ps
> 不只能观察进程，同时还可以显示每个进程使用CPU的情况
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcypb8tuj212q0l8n3o.jpg)

使用`ps aux`(BSD风格)可以查看所有进程的细节信息，重点查看%CPU一列。 也可以使用`ps -ef`(SVR4风格)查看TIME一列(从创建到当前为止，所消耗的CPU的总时间)。

6. top
> 显示最消耗CPU的任务和CPU消耗百分比

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzcztntb7j215s0qkn3i.jpg)

top显示的数据大体来说和mpstat显示的数据会保持一致，但top的数据是按照一定的频率对`/proc`目录做快照，并计算里面的数据。 所以如果有存在期非常短暂的进程，那么可能会遗漏这样的进程。

如果当前系统中存在大量的`短命`进程，那么建议使用atop。

7. pidstat
> 为进程或者线程显示CPU用量
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzd0p6yekj20xy0eojvs.jpg)

pidstat默认只显示活动进程的CPU用量信息。显示的数据包括: 用户态、内核态、CPU使用率和使用的CPU核号。

如果想输出所有的进程，那么就使用`-p ALL`。

8. time和ptime
> 显示指定进程的CPU数据

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzzd1l5gljj20v60da0ts.jpg)

只有想确定单个进程时，才会使用这个命令。


