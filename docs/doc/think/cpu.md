# 关于go-zero性能的一些想法 - 02可怕的沙子

在上一篇中，通过go-zero的一个性能问题引发了我的兴趣。顺着这个事件，我努力的钻入到系统内部一探究竟。 为了保留自己的思考过程，我准备把探险经过记录下来。

## CPU的物理组成

在说CPU的时候，经常会说几个名词：物理核、逻辑核、超线程、调度器等等。 这些名词到底说的是什么意思？ 为了给后面创建一个基线，现在明确一下这些名词的定义。 

+ 物理核
    插在主板上的物理处理器。 这些处理器是从几个大厂直接购买的，内部封装了超大规模的集成电路。 什么又是集成电路？ 集成电路通俗指的是有逻辑门(晶体管)组成的微电子器件组合。  
+ 逻辑核
    和虚拟CPU差不多是一个意思。是有物理核通过线程的方式提供的CPU完整实例。物理核和逻辑核的关系大致如下：
    ![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzoy1p88zej21980k240u.jpg)

+ 队列
    每个逻辑CPU都是众多线程增强的对象，为了雨露均沾，每个逻辑CPU都有若干个队列(运行队列，等待队列)。 所有等待CPU的线程都在队列中排队。
    ![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzoy6wb2qoj20qm0wctc5.jpg)

+ 调度器
    调度线程进入队列的内核子系统

CPU属于计算硬件，每一次的计算表示若干门电路的与或非结果。而什么时候开始计算，什么时候停止计算。则是由一个电子信号来通知的。 当来一个高电平时，开始计算。 当来一个低电平时，停止计算。这样高低电平不停的循环下去，CPU就可以持续不断的计算下去了。

一个高低电平脉冲信号就是一个时钟周期，1秒中可以发生时钟周期的次数越高，就表示CPU在单位时间内计算次数越多。 那么CPU的性能就越高，同样能耗就越高(每一次的电信号都是一次能量转化)。为了可以量化的表示CPU性能，就将1秒中时钟周期发生的次数表示为主频。比如3GHz主频的CPU，每秒可以运行三十亿次时钟周期。


CPU属于计算组件，那么就表示有输入有输出。 CPU内部体积有限，无法存储大量数据。所以就需要外部组件帮忙存储数据，但CPU的运算速度远远大于其他组件的读取速度(其他组件的集成电路规模远远小于CPU)。所以为了不浪费效率，CPU内部就集成了缓存。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzoywiydatj20we0neq7t.jpg)

所有的物理CPU共享三级缓存，每个物理CPU内部共享二级缓存，每个逻辑CPU独享一级缓存。


## CPU的基本运行

CPU每次的计算不是盲目的计算，它是遵循特定的运行规则。这些运行规则就称之为指令。 每种CPU都有不同的逻辑电路，而不同的逻辑电路就需要量身定制一套指令，这一套指令就称之为指令集。比如Intel的X86属于一种逻辑电路设计，那么它对应的指令集就成为X86指令集，ARM属于另外一种电路设计，那么就称为ARM指令集。 不同的指令集相互不能混用(底层电路设计不同，无法处理对方莫名其妙的指令)。

CPU每次执行指令的时候，需要经过：
- 取指令
- 指令解码
- 执行指令
- 读取操作数
- 保存结果

读取操作数和保存结果属于可选项，如果某些指令仅仅操作寄存器，那么就不需要从缓存或者内存读取数据了(例如修改下一个指令位置的指令)。这些步骤有时执行的快，有时执行的慢。 为了不浪费效率(都是穷惹的祸)，现在的CPU都允许同事执行不同指令的不同部分，也就是将以前串行执行指令，变成了有条件的并发执行指令。

这种方式就称为指令流水线。通过指令流水线，可以在一个时钟周期内完成多个指令。
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzp08m0ywoj20q40owgof.jpg)

假设一个命令需要四个指令才能完成，如果没有流水线，那么只能四个指令串行执行。 如果这四个指令中，有两个指令是没有依赖关系的，那么无依赖关系的指令就可以在两条流水线中并发执行。这样只需要两个时钟周期就可以完成命令了。

这就引申出另外一个术语：CPI和IPC(好吧，是两个不同的术语)。 

**CPI**是指令周期数，也就是平均完成一个指令需要几个周期(不要认为一个指令一定在一个周期内可以完成，指令分长指令和短指令，都不一定能在一个周期内完成)。

**IPC**表示每个周期内可以完成多少个指令，所以从数学公式上面可以推导出 IPC=1/CPI。

如果CPI高，则表示当前运行慢指令(比如需要频繁读取低速存储的指令)较多，消化不良。 如果CPI低，说明当前CPU战斗力惊人，来一个消灭一个。

但CPI不容易计算(其实是不利于人类观看，CPU干啥不是干，CPU不关心CPI的高和低)。为了可以形象直观的表示当前CPU是否繁忙，就提出了利用率这个概念。

CPU利用率是单位时间内CPU用于执行工作的时间占比。 CPU利用率和IPC成正比，CPU利用率高表示当前正在快速的处理指令。为了进一步细分CPU到底是在忙工作还是搞私活，就分出了内核态时间和用户态时间两个维度。

执行用户编写代码的时间称之为用户态时间，而用于系统调用，内核线程和处理中断的时间则称为内核态时间。

由此就对程序分出了三六九等，图像处理、科学计算和数据分析，这些玩命压榨CPU的称为计算密集型代码。 而依赖读写磁盘，等待网络事件的代码就称为IO密集型代码。 

计算密集型代码CPU利用率高属于正常情况，反之IO密集型代码如果CPU利用率也高，就诡异了。

## CPU的繁忙

那怎么才算正常，怎么才算不正常呢？ 作为程序员，我们需要对这个问题进行量化处理。 就发明了饱和度这个名词。 

一个逻辑CPU如果使用率是100%就称为饱和CPU。如果在此时还需要给这个CPU安排工作，那么CPU心有余而力不足，只能让新来的人做冷板凳，也就是放到运行队列等着去。什么时候有空了，什么时候就运行这个线程。 排队的线程个数就有了个优雅的名词：Load

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzp0vabwlyj20ji0zgjuy.jpg)


马克思列宁主义告诉我们，但凡有不平等一定就会有特权。 排队的线程中可能有着急干活的，有不着急躺平的。 为了体现出能者多劳和特权思想，Linux内核为每个线程发送一个优先级标识。 高优先级的线程有可能会比前面排队的线程更快的运行自己。 这种就称为抢占机制。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzp11l2ltoj20mk10awiu.jpg)