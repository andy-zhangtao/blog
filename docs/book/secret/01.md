# 密码体系一 - 启蒙

> 描述密码体系中场景类型和使用场景

我们的文章从炒鸡蛋开始讲起，有时加密过程就和炒鸡蛋过程很相近。 炒鸡蛋时，将鸡蛋打碎，然后开始搅拌。当蛋清和蛋黄被搅碎到一起时，我们已经无从分辨哪块是蛋清，哪块是蛋黄了。从密码学的角度来说，此时此刻，这盘炒鸡蛋已经完美`隐藏`了原有信息。同时也达到了无法`还原`原有数据的目的。

对于炒鸡蛋来说，这项工作可以认为结束了。 但对于密码学来说，这仅仅完成了第一步：隐藏信息。在实际场合当中，当信息被隐藏之后，我们还需要将数据还原回来。 所以隐藏的过程就称之为`加密`，还原的过程就称之为`解密`。而在隐藏和还原时使用的方法就称之为加密算法。

一般来说，根据双方是否使用相同的密钥处理数据，加解密可以分为两大类:

- 对称密钥
- 非对称密钥

典型的对称密码有: DES、3DES、AES 等算法。非对称密钥: RSA、椭圆曲线和 Rabin 等(如果我能充分吸收这些算法原理的话，我会在后面文章中逐个解释实现细节)。

虽然我们平时使用加解密比较多，但有的时候却需要验证信息是否发生过篡改。 比如下面的场景：

有非著名的三个人，Bob、Alice 和 Eve。 其中 Bob 向 Alice 发消息: "我喜欢你"(不要问这种话为什么不当面说，如果当面说那么就没有下文了)。

如果 Eve 截获了双方传递的消息，那么完全可以篡改 Bob 的消息，将"我喜欢你"改为"我不喜欢你"，一下子就棒打鸳鸯散了。

为了防止有情人被拆散，每次 Bob 再发消息的时候，都需要单独计算消息的"指纹"。然后将"指纹"数据一同发送给 Alice。Alice 收到信息后，需要重复计算消息指纹，并将自己计算的指纹和 Bob 发来的指纹进行比对。 如果一致，那么就说明消息没有被篡改过。 如果不一致，就说明有第三者窃听并篡改了消息。

而这个"指纹"就是通过`单向散列函数`计算出来的，计算"指纹"就是为了防止第三者`篡改消息`。

常见的单向散列函数有：

- MD4、MD5
- SHA-1、SHA-2(SHA-256、SHA-384、SHA-512)
- SHA-3(Keccak)

但这里还有个疑问，**既然 Eve 能截获双方消息，那么完全可以重新计算一份"指纹"传送给对方，如何防止这种情况呢？**

这就是`认证`了。

认证简而言之，就是证明这个消息是从 Bob 发给 Alice 的。 无论里面的内容是"我喜欢你"还是"我不喜欢你"。这都是 Bob 真实意思的表现。

为了达到这个目的，就需要完成两个动作：1. 确保信息不被篡改。2. 确保一定是 Bob 发起的消息。

在密码体系中，通过`消息认证码`完成这个工作。何为`消息认证码`呢？简单来说，用双方约定好的密钥计算消息的`单向散列值`。对方收到消息后，使用约定好的密钥再重新计算一次。 如果一致就说明消息没有被篡改过，同时也是对方发来的(当然此时此刻我们假设密钥没有被泄露)。

**那问题就又来了，既然`消息认证码`也是通过共享密钥来计算的，那为啥不直接对消息进行加密传输呢？**

现在还是点对点的问题，也就是 Bob 和 Alice 俩人之间的通讯问题。如果变成点对面呢？比如说我们要登陆网银操作时，我如何确认浏览器中打开的这个网页就是真实银行的界面，而不是山寨诈骗团队的页面呢？

这就需要依靠`证书`了。

`证书`用来证明证书所有者是合法的所有者，这有点类似于证明"你爸是你爸"的意思。我说我是银行，你不行。 那我找了一个第三方，让他证明我是银行总可以了吧。 但问题又来了，我们又该如何确认这个第三方是可信的，而不是一个山寨机构呢？

回到现实中来，就演变成了`证书`来证明我是我，但`证书`如何确保自己是可信证书呢？ 这就牵涉到`证书链`了，也就是说通过另外一个第三方来证明`证书`的有效性，然后再通过另外一个`第三方`来证明刚才的`第三方`，一直如此递归。 说实话，这样推下去就是俄罗斯套娃了。无穷无尽。

所以追溯到根时，就变成自己给自己颁发证书。也就是根 Root 给自己做背书，我就是我，爱信不信。

其实说到底，密码体系问题就是数学问题，加解密就是将原文与密钥进行数学运算和逆运算。 单向散列就是借助某种数学算法，将原文计算出固定长度。而消息认证码和证书，同样是数学知识的混合运算。

所以学好数学很重要，再不济也能考讲解密码体系，混口饭吃。

在文章最后，我送上本节启蒙的思维导图。后面伴随着内容慢慢展开，这个图也会慢慢丰富起来。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h4lvw9te8lj22fa0r8wla.jpg)
