# 关于go-zero性能的一些想法-03关于CPU不可不说的那些事

书接上文。 上篇说道每个CPU都存在一个执行队列，需要执行的任务会在队列中排队依次等待CPU的"召唤"。理想的调度模型是按照"能者多劳"的方式调度，谁重要，谁最需要CPU，谁就上。 但事实上，这个标准很难拿捏。所以就出了不少的调度算法。

当前Linux的调度策略大致如下：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzsfdvrsqxj20l80zawjk.jpg)

当前正在消费的线程如果出现的是：
1. 自愿上下文切换。那么就会主动放弃CPU的使用权。转身自己再去执行队列队尾排队去。 当前队列中的线程就可以通过分时抢占的方式获取CPU余下时间的使用权。
2. 非自愿上下切换。此时此刻，属于线程被强行放弃了CPU的使用权(比如等待IO)。 这个时候线程已经失去了继续使用CPU的资格，所以就会被放到休眠队列中，直到满足使用CPU资格后再次唤醒。人闲事不闲，如果现在有更高优先级的线程，就可以通过抢占的方式使用CPU了。

目前Linux中使用CPU的方式有两种：多进程和多线程。但无论是进程还是线程，需要满足的定律是：进程是资源分配的基本单位，线程是调度的基本单位。

两种方式使用的CPU的区别如下：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzsfvl6sutj213o0by40t.jpg)

而检查CPU是否存在性能问题时经常使用的工具有两类：定性工具和定量工具

|类型|名称|描述|
|---|----|---|
|定性|uptime｜检查给定时间内CPU饱和度趋势(也就是观察Load值)
||vmstat|检查运行队列和阻塞队列中的任务数量(如果阻塞队列中的任务太多就说明大量线程再等IO)|
||mpstat|如果当前是多核CPU平台时，找出最繁忙的那个CPU|
||top/prstat|通过全局视图，找到性能大户|
||pidstat/prstat|找到性能大户中的内核时间和用户态时间|
|定量|perf/dtrace/stap/oprofile|内核调用跟踪，找到那个函数如此之消耗CPU|
||cpustat|可以测量CPI|

在使用定性工具分析CPU时，可以考虑使用`USE`大法。 USE具体指的是：
1. 使用率(CPU繁忙的时间)
2. 饱和度(CPU平均Load值，阻塞队列平均深度)
3. 错误率(CPU使用时发生的错误)

这里面错误率如果没有意外情况的话，零应该是预期值，不应该出现很多。但使用率和饱和度，需要区分是采集容器的值还是宿主机节点的值。

如果是容器的值，那么使用率需要考虑容器中CPU资源额度的问题。同时不需要采集饱和度(因为饱和度是全局的，并非单个进程的)

如果采集的是宿主机节点值，那么就可以采集当前节点的使用率和饱和度数据了。

在Kubernetes环境当中，在不想改动代码的前提下提高性能，可以采取的`旁门左道`如下：
1. CPU分组，指定某些CPU作为一个分组，并且只能运行某些进程
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzsgdaklmlj20qq0co0v7.jpg)

2. CPU亲和性。 指定当前进程只在某个CPU上面运行。
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzsgfx8q3rj20t80eojv1.jpg)

这两种方式的区别在于，CPU分组是分组内的CPU只能运行某些进程，其他进程一概不处理。 而CPU亲和性，则指的是某个进程只能在某个CPU上面运行，不去其他CPU运行。 而相同点则是最大程度的保证CPU中的一级缓存不失效。(`一级缓存读取速度是<10个时钟周期， 二级缓存是<100个时钟周期，三级缓存<1K个时钟周期，访问内存则是50ns左右`。)

3. 调整进程优先级(修改nice值)。但不推荐修改，可能会发生蝴蝶效应。