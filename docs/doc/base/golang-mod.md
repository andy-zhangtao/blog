# Golang 依赖管理进化史

诚然，说进化史有些大。 不免有些夸大其词的感觉，但从golang 1.x 到最新的golang 1.18，golang的依赖管理一路跌跌撞撞，总算是大功告成，也对得起进化史这三个字了。

为了可以直观看到golang 依赖管理的进化历程，我根据自我理解做了下面这张图:
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h16675dlvsj21p40nyjy5.jpg)

从时间节点中划分，golang的依赖管理大致分为四个阶段:

+ 草莽英雄。 在1.11之前，golang延续的是google的依赖管理风格(没有所谓的版本概念，所有代码都使用同一个版本的依赖)。这个阶段的特点是，所有的golang project都复用相同的依赖。无论是Project A还是Project B，依赖的代码都是同一份(根本原因在于所有的依赖保存在gopath中，所以依赖完全相同)。 如果想分离依赖，那好办。自己创建vendor目录，自己维护vendor。

+ 三国纷争。后来golang官方意识到，不是所有的公司都叫google，不是所有的开发都是`研发`(中间还夹杂着golang姓`G`还是姓`社`的斗争)。为了照顾那些技术底子不强的公司，golang官方实验性质的推出了`go.mod`文件，这个文件保存着当前工程所有的依赖文件和版本。因为是实验性质，所以推出了`GO111MODULE`这个环境变量来启动或者关闭。与此同时围绕着`go.mod`文件，也推出了一些工具。但最常用的还是`godep`。 后来golang掌门人连发几篇博文阐述`vgo`方案，虽然社区有很多反对的声音，但最终胳膊肘子拧不过脖领盖儿，golang在1.13的时候正式将`vgo`扶正，变成了`go module`方案

+ 一统天下。 从1.13到1.17，伴随着社区对`go module`精神的深入学习，大家一致认为虽然`rsc`行事粗鲁，但小伙思想还是挺具有前瞻性的。 `go module`尽管有这样那样不好的地方，但和以前的依赖管理方案比起来，强太多了。社区届纷纷表示`真香大法`就是好。

+ 继往开来。 在1.18中，伴随着`go workspace`的落地，golang的依赖管理方案算是完成了万里长征最后一步，不但修复了`go module`遗留的那些个毛病，顺手还做了精神升华。

## go module的好

在没有`go module`之前，golang典型的依赖方式是将依赖代码放在GOPATH中，构建的时候，直接从GOPATH读取所依赖的代码。如果golang工程之间相互依赖的版本不同那还好，相互不影响。
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h18786ij5zj20a80j63yz.jpg)

但这种事情怎么可能是常态？ 所以慢慢的就变成了多个golang工程会依赖同一个库的不同版本。
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h187b1jas6j20rm0iqjud.jpg)

出现这种情况后，相互就会影响。 一个典型的表现就是A工程和C工程以前可以构建成功，但当B工程依赖高版本的依赖库以后，A和C就构建失败。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h187cxyti9j20rk0j0ad4.jpg)


`go module`就是用来解决这种依赖冲突问题的。 `go module`通过`go.mod`文件来描述当前工程依赖了哪些第三库，以及各自的版本号。 每个工程都有各自的`go.mod`文件，这也就表示每个工程之间可以相互独立的描述各自依赖。从这个角度来说，如果你启用了`go module`，那么就不可以不再需要`GOPATH`了。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h187oz2a7lj20sa0ku77s.jpg)

当我们在工程中执行`go mod init`以后，就会创建一个空的`go.mod`文件。当在代码中引入了第三方依赖包以后，通过执行`go mod tidy`就可以自动将当前依赖库和相对应的版本写入`go.mod`文件。 例如下面的文件

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h187y24ra6j20u00u043h.jpg)

`go.mod`文件结构分为以下几个部分：

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h188n0t49hj21750u042q.jpg)

在文件中，可以看到几种特殊的标识符。这几类标识符是`go module`在发展过程中挖坑太多，自作孽😂。 我们逐个看一下。

+ v0.0.0-20191009025716-f1972eb1d1f5  

    这是一个伪版本号，表示这个库没有使用`go module`组织依赖库，所以就没有`go.mod`文件。`go module`为了兼容这些个老库，就为它们创建了一个伪版本号。

    f1972eb1d1f5是最近一次commit的hash值，而20191009025716则是commit的时间。而0.0.0则有几种不同的生成规则：

    1. 如果没有base version,那么就是vX.0.0的形式
    2. 如果是一个pre publish版本，那么就是vX.0.0-pre.0的形式
    3. 如果是一个正式publish版本，那么就是vX.Y.(Z+1)-0的形式

    说实话，go module真是操碎了心呀

+ indirect

    依赖的依赖，也就是间接依赖的情况。 但很奇怪，既然每个库都有`go.mod`了，那为什么还需要单独罗列这些库呢？

    所以间接依赖这四个字并不准确。 准确来说应该是依赖某个库，但这个库在任何go.mod都找不到，这个时候就会给个`indirect`标记。

+ incompatible

    不兼容。 字面意思是依赖库存在版本不兼容的情况，但其实指的是代码结构不兼容。 比如 `example/demo v2.2.1+incompatible`，指的是当前依赖库应该应该是有`example/demo/v2`这样的目录结构，但实际上并没有这样的结构，所以添加一个不兼容的标签。

+ exclude

    这个类型的标签没有在上面`go.mod`文件体现出来，它表示的是排除某些库。一般来说，如果某些库不合适，go会自动剔除掉。 但如果你确定，肯定以及一定某些库肯定不需要依赖了，这个时候就通过`exclude`来指定这些需要排除的库。

+ replace

    这种标签经常用在本地调试阶段，比如你认为官方某个库有问题，自己fork到本地。通过`replace`将`go.mod`中的库替换成本地库。这样编译的时候，就会使用本地库了。 

    但要注意，如果本地`go.mod`使用了`replace`，不要随便commit。以免污染其他伙伴的环境。这个问题在`go 1.18`中得到了解决。

除了`go.mod`文件，还有一个`go.sum`文件。 这个文件用来保障当前缓存的模块不会被篡改。 缓存在哪里呢？  嗯，直接去`$GOMODCACHE`目录看就可以了。

除了上面针对`go module`的基本介绍之外，还有一个很重要的内容：`go module`如何确定依赖库版本的？ 它如何知道应该选择v1.0.0还是v2.1.1呢？ 这是另外一个很重要的概念: `最小版本抉择（MVS）`

> 有兴趣的人可以直接读rsc的原著[Minimal Version Selection](https://research.swtch.com/vgo-mvs)

简单来说，`mvs是一个有向无环图，每个顶点表示一个依赖库，而点与点之间的边表示版本要求`。

生成有向无环图时，首先从当前工程模块的`main.go`开始(因为当前模块是最干净的代码，干净表示目前仍处于开放阶段，版本为0)。 然后依次递归检索所有的依赖库，同时记录依赖库的每个版本。当遇到环时，`go mod`会提示出现循环依赖，报错退出。 如果安全走到了最后，此时就开始匹配各个依赖库的最高版本，俗称为每个依赖库找到`最大公约数`。

借用rsc的图来表示这个过程:

![](https://cdn.learnku.com/uploads/images/202110/21/1/iBnQP2Wokm.png!large)

图中，main依赖模块 A 和 模块 B。 A和B都依赖C，C依赖D (有点像三角恋的感觉一样，但三角恋是有环图，所以像但却不是)。

在第一次构建的时候，`go mod`先生成下面这个图:
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h18gojqj0tj20xm0tm0yt.jpg)

注意在生成图的过程中，已经顺手获取了每个依赖库的版本。

然后按照四个原则进行裁剪:
1. 主干有环的不要
2. 支干有环的裁剪
3. 版本就高不就低
4. 直接依赖高于间接依赖

按照这个原则，E和F就不能要了，因为E和F构成了环，所以被裁剪掉。这样`B 1.3`版本也就出局了。 因为`B1.3`引入了E和F的环，所以不能要。 那么按照就高不就低的原则， 保留`B1.2`版本

同理保留`A1.2`，因为就高不就低。 

然后`A`和`B`分别依赖了`C1.3`和`C1.4`按照就高不就低的原则，保留`C1.4`。最后`C1.4`依赖了`D1.2`，按照`直接`高于`间接`的原则，保留`D1.2`,放弃`D1.3`。

最后将结果写入`go.mod`文件，如果需要生成`vendor`目录，就按照这份清单生成就可以了。


## go module的坏

`go module`再好也不是万能的，如果真是万能的，那纯属骗小孩呢。 下面就来说说`go module`的不足。 

平心而论，`go module`的不足大部分都是为了当初那个`向下兼容`的承诺。 比如第一个不足：

1. 恶心的`replace`

    如果我们都使用官方提供的依赖库，那么一切都会非常美好。 但如果很不幸，你使用的依赖库有这样那样的问题，用起来不爽的时候。 你可能一怒冲冠，就在本地fork一份开始调试。 
    
    此时为了可以让你的代码构建的时候，使用本地的而不使用官方的。你就需要使用`replace`进行`乾坤大挪移`的操作。 具体做法请参考`replace`的用法。 

    你爽了，一时不小心commit到仓库中，这下可就坑苦其他人了。 因为其他人更新代码后，会发现`go.mod`里面多了个`replace`，而且这个地址自己本地还没有。所以恶心至极。

    那怎么办？ 只能改掉重新commit。

2. 恶心的本地开发问题

    这个场景可能在国内更常见一些，本地开发的golang代码依赖了一个本地另外一个库。 而这个库恰好还没有发布到仓库中。 自己本地开发起来，风驰电掣，好爽不爽。 
    
    但其他人pull以后，只能大X蹬小X。因为本地压根就没有那份神秘的仓库...

这些问题我猜测是rsc始料未及的，获取压根就没想到在地球的另外一端，居然还有一波下班不提交的人(何止下班不提交代码呢，还有整天整天不健身的人呢 😄)

所以虽然`go module`可以解决90%的问题，但总归还有一丝小缺陷。 而这些缺陷，在下面`go workspace`中得到了解决。

## go workspace解决了哪些问题

`go workspace`是go 1.18推出的新特性。`go workspace`通过引入一个go.work文件用于开启Go工作区模式。

在`go.work`文件中目录共同构成了一个工作区，`go module`优先使用工作区中的`go.mod`。

例如我们在`go.work`中规定:
```
go 1.18
  
directory ./.

replace xxxx  =>  <new package path>
```

这样设置好以后，当运行`go mod`命令时，go就会将`go.work`中的值覆盖当前`go.mod`里面的值。这样就可以在保证`go.mod`不被修改的前提下，满足自己个性化需求。 

而从这里也可以看出，`go.work`文件是**不能commit的！**

同时还可以使用`go.work`来管理`go.work`，也就是用一个工作区来管理多个工作区。 有机会的话再单独分享这块内容。 


go 1.18刚发布不久，我也是在逐步学习`go.work`的使用，如果上面那些内容不对，还希望你们能提出。

